# Data/antigen.fasta
>antigen_1
KRAKWPAMRCHEYGQACRQSFYIWVLPYGNYTHHAKIYEGIQLCYPHKASMMKGWFTSTPAEEFWQLCTNKWHEPEFCES
GVFYHFVVYKQHLLTAKYKCYGTYNCMCMINTEHLAYCGGNYARHNRLFFTMDIRWVWFQTLLDWKLQHAPGNMSFCWWE
GMKVRNWSHLFKCKIKQGPRSWVMFDRYHERSNGYMKIVCHEDDKRNQVNPIVWRFFKSDFMYDERETHCLKMSPTQYQE
GNYLDTMQMKLWTQQVSAKIPIAENIWTYCHHAWGEWKMDIAIPNLDVSKAINSVQYAEGFNDNHVSSTAFLWKDDFYGK
NKSCHCKAMGFTTMHIIFMYFLVGPENFDEPFCSSNYDLWAFHGFDLLDVYVTHYIDSIVANDLCCVTGASVIWRSRHSY
HFHGCQCFMDYSSNGGFGANVWILAYRDLIERITTVQKGEGITLYKWPLCSRDWIMFKPNHAEMWELLAWCNILCPNRHY
FRNPIICKNDIVMIALCKWWMVCSLDKRKIGPLEPFVCRHYQAYPCQCPPGLLPMDLSISLCTASMMGQLVVEVLQCLEK
VYSYIWITHDQPIWTASEIPGVDCNGSYCLVDLVEMEVML

Data/antigen.fasta: Secuencia proteica de un antígeno de 600 aminoácidos utilizada como dataset 
para el algoritmo de optimización. Representa la estructura biológica sobre la cual se  evalúa la cobertura de epítopos.

# Implementación del CLONALG en /src/clonalg.py
import numpy as np
import matplotlib.pyplot as plt

def read_fasta(file_path):
    """Lee archivo FASTA y devuelve la secuencia"""
    with open(file_path, 'r') as file:
        lines = file.readlines()
    sequence = ''.join(line.strip() for line in lines if not line.startswith('>'))
    return sequence

def fitness(x, antigen_length=600, k=10, gamma=0.1):
    """
    Función de fitness para cobertura de epítopos
    x: vector de solución (15 dimensiones)
    """
    # Convertir el vector de solución en posiciones de péptidos
    positions = (x * (antigen_length - k)).astype(int)
    
    # Calcular cobertura
    coverage = np.zeros(antigen_length)
    for pos in positions:
        if pos >= 0 and pos + k <= antigen_length:
            coverage[pos:pos+k] += 1
    
    # Métricas de cobertura
    unique_coverage = np.sum(coverage >= 1)
    total_coverage = np.sum(coverage)
    overlap = total_coverage - unique_coverage
    
    # Número efectivo de péptidos seleccionados
    effective_peptides = np.sum(x > 0.1)  # Umbral para considerar seleccionado
    
    # Cálculo del fitness
    score = unique_coverage - gamma * overlap
    return score, unique_coverage, total_coverage, effective_peptides, coverage

def clonalg_algorithm(D=15, N=40, beta=2, d_rate=0.1, generations=150, seed=6):
    """
    Implementación del algoritmo CLONALG para cobertura de epítopos
    """
    rng = np.random.default_rng(seed)
    
    # Inicializar población
    population = rng.uniform(0, 1, (N, D))
    best_solution = None
    best_fitness = -np.inf
    fitness_history = []
    
    for gen in range(generations):
        # Evaluar fitness
        fitness_scores = []
        for individual in population:
            score, _, _, _, _ = fitness(individual)
            fitness_scores.append(score)
        
        fitness_scores = np.array(fitness_scores)
        
        # Actualizar mejor solución
        current_best_idx = np.argmax(fitness_scores)
        current_best_fitness = fitness_scores[current_best_idx]
        
        if current_best_fitness > best_fitness:
            best_fitness = current_best_fitness
            best_solution = population[current_best_idx].copy()
        
        fitness_history.append(best_fitness)
        
        # Selección y clonación
        sorted_indices = np.argsort(fitness_scores)[::-1]
        elites = population[sorted_indices[:N//5]]
        
        clones = []
        for i, elite in enumerate(elites):
            n_clones = int(beta * (N//5 - i)) + 1
            for _ in range(n_clones):
                mutation_rate = 1.0 / (fitness_scores[sorted_indices[i]] + 1e-9)
                clone = elite + rng.normal(0, mutation_rate, size=D)
                clone = np.clip(clone, 0, 1)
                clones.append(clone)
        
        # Nueva población
        new_population = np.vstack([population, np.array(clones)])
        new_fitness = np.array([fitness(ind)[0] for ind in new_population])
        best_indices = np.argsort(new_fitness)[::-1][:N]
        population = new_population[best_indices]
        
        # Diversificación
        n_new = int(d_rate * N)
        population[-n_new:] = rng.uniform(0, 1, (n_new, D))
    
    return best_solution, best_fitness, np.array(fitness_history)

def analyze_solution(best_solution, antigen_length=600, k=10):
    """Análisis detallado de la mejor solución"""
    score, unique_cov, total_cov, eff_peptides, coverage = fitness(best_solution, antigen_length, k)
    
    print("=== ANÁLISIS DETALLADO DE LA MEJOR SOLUCIÓN ===")
    print(f"Fitness final: {score:.4f}")
    print(f"Péptidos seleccionados: {eff_peptides:.2f}")
    print(f"Cobertura única: {unique_cov}/{antigen_length} posiciones ({unique_cov/antigen_length*100:.2f}%)")
    print(f"Cobertura total (con solapamientos): {total_cov:.1f}")
    print(f"Posiciones con solapamiento: {total_cov - unique_cov:.0f}")
    
    return coverage, eff_peptides, unique_cov

def plot_results(fitness_history, coverage, best_solution, antigen_length=600):
    """Genera todas las gráficas de resultados"""
    
    # Gráfica 1: Curva de convergencia
    plt.figure(figsize=(10, 6))
    plt.plot(fitness_history, linewidth=2)
    plt.title('Curva de Convergencia - Algoritmo CLONALG', fontsize=14)
    plt.xlabel('Iteración')
    plt.ylabel('Fitness')
    plt.grid(True, alpha=0.3)
    plt.savefig('resultados/graficas/convergencia.png', dpi=300, bbox_inches='tight')
    plt.close()
    
    # Gráfica 2: Cobertura del antígeno
    plt.figure(figsize=(12, 4))
    plt.plot(coverage, alpha=0.7)
    plt.fill_between(range(len(coverage)), coverage, alpha=0.3)
    plt.title('Cobertura del Antígeno por Péptidos Seleccionados', fontsize=14)
    plt.xlabel('Posición en el antígeno')
    plt.ylabel('Número de péptidos cubriendo')
    plt.grid(True, alpha=0.3)
    plt.savefig('resultados/graficas/cobertura_antigeno.png', dpi=300, bbox_inches='tight')
    plt.close()
    
    # Gráfica 3: Distribución de péptidos
    plt.figure(figsize=(10, 6))
    positions = (best_solution * (antigen_length - 10)).astype(int)
    plt.scatter(positions, np.ones_like(positions), s=100, alpha=0.6)
    plt.title('Distribución de Péptidos Seleccionados', fontsize=14)
    plt.xlabel('Posición de inicio en el antígeno')
    plt.yticks([])
    plt.grid(True, alpha=0.3)
    plt.savefig('resultados/graficas/distribucion_peptidos.png', dpi=300, bbox_inches='tight')
    plt.close()

    # Crear entorno y instalar dependencias
pip install -r requirements.txt

# Ejecutar el notebook
jupyter notebook notebooks/analisis_clonalg.ipynb

#  ejecutar como script
python -c "
import sys; sys.path.append('src')
from clonalg import clonalg_algorithm, analyze_solution
best_sol, best_fit, hist = clonalg_algorithm()
coverage, eff_pep, unique_cov = analyze_solution(best_sol)
print(f'Resultados: Fitness={best_fit:.2f}, Péptidos={eff_pep:.2f}, Cobertura={unique_cov}/600')
"