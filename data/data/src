src/clonalg.py: Implementación del algoritmo CLONALG (Clonal Selection Algorithm) que optimiza la 
selección de péptidos para maximizar la cobertura del antígeno mientras minimiza solapamientos redundantes. 
Incluye funciones para cálculo de fitness, evolución de soluciones y generación de visualizaciones.
#2. Algoritmo CLONALG
Implementación fiel del algoritmo de selección clonal
Optimización en espacio continuo [0,1] con conversión a binario
Operadores de selección, clonación proporcional y mutación adaptativa
Mecanismos de diversificación para evitar convergencia prematura

#3. Función de Fitness Especializada
Maximiza cobertura única de epítopos
Penaliza solapamientos redundantes (gamma=0.1)
Evalúa distribución espacial en el antígeno

Conversión automática de soluciones continuas a discretas
import numpy as np
import matplotlib.pyplot as plt
import json
import os

def read_fasta(file_path):
    """Lee archivo FASTA y devuelve la secuencia"""
    try:
        with open(file_path, 'r') as file:
            lines = file.readlines()
        
        sequence = ''.join(line.strip() for line in lines if not line.startswith('>'))
        return sequence
    except FileNotFoundError:
        print(f"Error: No se encontro el archivo {file_path}")
        return None

def fitness(x, seq, k=10, gamma=0.1):
    """
    Funcion de fitness para cobertura de epitopos
    - Convierte entrada continua [0,1] a binaria
    - Maximiza posiciones cubiertas
    - Penaliza solapamientos redundantes
    """
    # Convertir entrada continua a binaria (umbral 0.5)
    selected = (x > 0.5).astype(int)

    coverage = np.zeros(len(seq))
    for i in range(len(selected)):
        if selected[i] == 1:
            start = i
            end = min(start + k, len(seq))
            for j in range(start, end):
                coverage[j] += 1

    covered_positions = np.sum(coverage > 0)
    total_coverage = np.sum(coverage)
    overlapping_penalty = total_coverage - covered_positions

    return covered_positions - gamma * overlapping_penalty

def clonalg_algorithm(D=15, N=40, beta=2, d_rate=0.1, generations=150, seed=6, antigen_seq=None):
    """
    Implementacion del algoritmo CLONALG para cobertura de epitopos
    """
    if antigen_seq is None:
        raise ValueError("Se requiere la secuencia del antigeno")
        
    rng = np.random.default_rng(seed)
    
    # Inicializar poblacion en espacio continuo [0, 1]
    population = rng.uniform(0, 1, (N, D))
    best_solution = None
    best_fitness = -np.inf
    fitness_history = []

    for iteration in range(generations):
        # Evaluar fitness
        fit = np.array([fitness(x, antigen_seq) for x in population])

        # Ordenar por fitness (mayor es mejor)
        idx_sorted = fit.argsort()[::-1]
        population = population[idx_sorted]
        fit = fit[idx_sorted]

        # Seleccionar elites (mejor 20%)
        n_elites = max(1, N // 5)
        elites = population[:n_elites]
        fit_elites = fit[:n_elites]

        # Parametros para mutacion
        f_min = fit_elites.min()
        f_max = fit_elites.max()

        # Clonacion y mutacion
        clones = []
        for i, elite in enumerate(elites):
            # Numero de clones proporcional al ranking
            nclones = max(1, int(beta * (n_elites - i)))

            for _ in range(nclones):
                # Tasa de mutacion adaptativa (inversa al fitness)
                if f_max - f_min < 1e-9:
                    mutation_rate = 0.1
                else:
                    mutation_rate = 0.1 * (1 - (fit_elites[i] - f_min) / (f_max - f_min))

                # Crear clon y mutar
                clone = elite.copy()
                mask = rng.random(D) < mutation_rate
                noise = rng.normal(0, 0.1, D)
                clone[mask] += noise[mask]
                clone = np.clip(clone, 0, 1)  # Mantener en rango
                clones.append(clone)

        # Unir poblacion y clones
        if clones:
            pool = np.vstack([population, np.array(clones)])
        else:
            pool = population.copy()

        # Seleccionar mejores
        f_pool = np.array([fitness(x, antigen_seq) for x in pool])
        idx_best = f_pool.argsort()[::-1][:N]
        population = pool[idx_best]

        # Diversificacion
        n_new = max(1, int(d_rate * N))
        population[-n_new:] = rng.uniform(0, 1, (n_new, D))

        # Registrar progreso
        current_best = np.max([fitness(x, antigen_seq) for x in population])
        fitness_history.append(current_best)

    # Encontrar mejor solucion final
    best_idx = np.argmax([fitness(x, antigen_seq) for x in population])
    best_solution = population[best_idx]

    return best_solution, np.array(fitness_history)

def analyze_solution(best_solution, antigen_seq, k=10):
    """
    Analisis detallado de la mejor solucion encontrada
    """
    # Convertir a binario
    best_solution_binary = (best_solution > 0.5).astype(int)
    
    # Calcular metricas de cobertura
    coverage = np.zeros(len(antigen_seq))
    for i in range(len(best_solution_binary)):
        if best_solution_binary[i] == 1:
            start = i
            end = min(i + k, len(antigen_seq))
            for j in range(start, end):
                coverage[j] += 1

    unique_coverage = np.sum(coverage > 0)
    total_coverage = np.sum(coverage)
    overlapping_positions = np.sum(coverage > 1)
    max_overlap = np.max(coverage) if len(coverage) > 0 else 0
    selected_peptides = np.sum(best_solution_binary)
    
    print("ANALISIS DETALLADO DE LA MEJOR SOLUCION")
    print("========================================")
    print(f"Fitness final: {fitness(best_solution, antigen_seq):.4f}")
    print(f"Peptidos seleccionados: {selected_peptides:.2f} de {len(best_solution)} posibles")
    print(f"Cobertura unica: {unique_coverage}/{len(antigen_seq)} posiciones ({unique_coverage/len(antigen_seq)*100:.2f}%)")
    print(f"Cobertura total (con solapamientos): {total_coverage:.1f}")
    print(f"Posiciones con solapamiento: {overlapping_positions}")
    print(f"Maximo solapamiento: {max_overlap} peptidos en una posicion")
    
    return coverage, selected_peptides, unique_coverage

def plot_results(fitness_history, coverage, best_solution, antigen_length=600):
    """
    Genera todas las graficas de resultados
    """
    # Crear directorio si no existe
    os.makedirs('resultados/graficas', exist_ok=True)
    
    # Grafica 1: Curva de convergencia
    plt.figure(figsize=(10, 6))
    plt.plot(fitness_history, 'b-', linewidth=2)
    plt.title('Curva de Convergencia - Algoritmo CLONALG')
    plt.xlabel('Iteracion')
    plt.ylabel('Fitness (Cobertura de Epitopos)')
    plt.grid(True, alpha=0.3)
    plt.savefig('resultados/graficas/convergencia.png', dpi=300, bbox_inches='tight')
    plt.close()
    
    # Grafica 2: Cobertura del antigeno
    plt.figure(figsize=(12, 4))
    plt.plot(coverage, alpha=0.7)
    plt.fill_between(range(len(coverage)), coverage, alpha=0.3)
    plt.title('Cobertura del Antigeno por Peptidos Seleccionados')
    plt.xlabel('Posicion en el antigeno')
    plt.ylabel('Numero de peptidos cubriendo')
    plt.grid(True, alpha=0.3)
    plt.savefig('resultados/graficas/cobertura_antigeno.png', dpi=300, bbox_inches='tight')
    plt.close()
    
    # Grafica 3: Distribucion de peptidos
    plt.figure(figsize=(10, 6))
    positions = (best_solution * (antigen_length - 10)).astype(int)
    valid_positions = positions[positions <= antigen_length - 10]
    
    plt.scatter(valid_positions, np.ones_like(valid_positions), s=100, alpha=0.6)
    plt.title('Distribucion de Peptidos Seleccionados')
    plt.xlabel('Posicion de inicio en el antigeno')
    plt.ylabel('Peptidos seleccionados')
    plt.yticks([1], ['Peptidos'])
    plt.grid(True, alpha=0.3)
    plt.savefig('resultados/graficas/distribucion_peptidos.png', dpi=300, bbox_inches='tight')
    plt.close()
    
    print("Graficas generadas y guardadas en 'resultados/graficas/'")

def run_reproducibility_test(seeds=[6, 42, 123], antigen_seq=None):
    """
    Ejecuta pruebas de reproducibilidad con diferentes semillas
    """
    if antigen_seq is None:
        raise ValueError("Se requiere la secuencia del antigeno")
        
    print("EVALUACION DE REPRODUCIBILIDAD")
    print("==============================")
    fitness_results = []
    
    for seed in seeds:
        solution, fitness_val = clonalg_algorithm(seed=seed, antigen_seq=antigen_seq)
        fitness_results.append(fitness_val[-1])
        print(f"Semilla {seed}: Fitness = {fitness_val[-1]:.2f}")
    
    fitness_array = np.array(fitness_results)
    print("\nRESULTADOS CONSOLIDADOS")
    print(f"Media del fitness: {fitness_array.mean():.2f} ± {fitness_array.std():.2f}")
    print(f"Mejor fitness global: {fitness_array.max():.2f}")
    print(f"Peor fitness global: {fitness_array.min():.2f}")
    
    return fitness_array

def save_metrics(best_fitness, selected_peptides, unique_coverage, total_coverage, antigen_length, reproducibility_results):
    """
    Guarda las metricas en formato JSON
    """
    os.makedirs('resultados/metricas', exist_ok=True)
    
    metrics = {
        'mejor_fitness': float(best_fitness),
        'peptidos_seleccionados': float(selected_peptides),
        'cobertura_unica': int(unique_coverage),
        'cobertura_total': float(total_coverage),
        'porcentaje_cobertura': float(unique_coverage/antigen_length * 100),
        'reproducibilidad': {
            'media': float(np.mean(reproducibility_results)),
            'desviacion_estandar': float(np.std(reproducibility_results)),
            'mejor_fitness_global': float(np.max(reproducibility_results)),
            'peor_fitness_global': float(np.min(reproducibility_results))
        },
        'parametros_algoritmo': {
            'dimension': 15,
            'poblacion': 40,
            'generaciones': 150,
            'factor_clonacion': 2,
            'tasa_diversificacion': 0.1,
            'semilla_principal': 6
        }
    }
    
    with open('resultados/metricas/resultados_detallados.json', 'w', encoding='utf-8') as f:
        json.dump(metrics, f, indent=2, ensure_ascii=False)
    
    print("Metricas guardadas en 'resultados/metricas/resultados_detallados.json'")